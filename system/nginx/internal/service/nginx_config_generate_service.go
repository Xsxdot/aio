package service

import (
	"fmt"
	"strings"

	errorc "xiaozhizhang/pkg/core/err"
	"xiaozhizhang/pkg/core/logger"
	"xiaozhizhang/system/nginx/internal/model/dto"
)

// NginxConfigGenerateService nginx 配置生成服务
// 负责将结构化参数渲染为 nginx 配置文件内容
type NginxConfigGenerateService struct {
	log *logger.Log
	err *errorc.ErrorBuilder
}

// NewNginxConfigGenerateService 创建配置生成服务
func NewNginxConfigGenerateService(log *logger.Log) *NginxConfigGenerateService {
	return &NginxConfigGenerateService{
		log: log.WithEntryName("NginxConfigGenerateService"),
		err: errorc.NewErrorBuilder("NginxConfigGenerateService"),
	}
}

// Generate 根据配置规格生成 nginx 配置文件内容
func (s *NginxConfigGenerateService) Generate(spec *dto.ConfigSpec) (string, error) {
	if spec == nil {
		return "", s.err.New("配置规格不能为空", nil).ValidWithCtx()
	}

	var builder strings.Builder

	// 写入描述注释
	if spec.Description != "" {
		builder.WriteString(fmt.Sprintf("# Description: %s\n", spec.Description))
	}
	builder.WriteString(fmt.Sprintf("# Type: %s\n", spec.Type))
	builder.WriteString("# Generated by NginxConfigGenerateService\n\n")

	// 生成 upstream 块（如果有）
	for _, upstream := range spec.Upstreams {
		upstreamContent, err := s.generateUpstream(&upstream)
		if err != nil {
			return "", err
		}
		builder.WriteString(upstreamContent)
		builder.WriteString("\n")
	}

	// 生成 server 块
	serverContent, err := s.generateServer(spec.Type, &spec.Server)
	if err != nil {
		return "", err
	}
	builder.WriteString(serverContent)

	return builder.String(), nil
}

// generateUpstream 生成 upstream 块
func (s *NginxConfigGenerateService) generateUpstream(upstream *dto.UpstreamConfig) (string, error) {
	if upstream.Name == "" {
		return "", s.err.New("upstream 名称不能为空", nil).ValidWithCtx()
	}
	if len(upstream.Servers) == 0 {
		return "", s.err.New("upstream 服务器列表不能为空", nil).ValidWithCtx()
	}

	var builder strings.Builder
	builder.WriteString(fmt.Sprintf("upstream %s {\n", upstream.Name))

	// 负载均衡算法
	if upstream.LoadBalance != "" {
		switch upstream.LoadBalance {
		case "ip_hash":
			builder.WriteString("    ip_hash;\n")
		case "least_conn":
			builder.WriteString("    least_conn;\n")
		}
	}

	// 服务器列表
	for _, server := range upstream.Servers {
		line := fmt.Sprintf("    server %s", server.Address)
		if server.Weight > 0 {
			line += fmt.Sprintf(" weight=%d", server.Weight)
		}
		if server.Backup {
			line += " backup"
		}
		line += ";\n"
		builder.WriteString(line)
	}

	builder.WriteString("}\n")
	return builder.String(), nil
}

// generateServer 生成 server 块
func (s *NginxConfigGenerateService) generateServer(configType dto.ConfigType, server *dto.ServerConfig) (string, error) {
	if server.Listen <= 0 {
		return "", s.err.New("监听端口无效", nil).ValidWithCtx()
	}
	if server.ServerName == "" {
		return "", s.err.New("server_name 不能为空", nil).ValidWithCtx()
	}
	if len(server.Locations) == 0 {
		return "", s.err.New("location 配置不能为空", nil).ValidWithCtx()
	}

	var builder strings.Builder
	builder.WriteString("server {\n")

	// listen 指令
	listenLine := fmt.Sprintf("    listen %d", server.Listen)
	if server.SSLEnabled {
		listenLine += " ssl"
	}
	listenLine += ";\n"
	builder.WriteString(listenLine)

	// server_name
	builder.WriteString(fmt.Sprintf("    server_name %s;\n", server.ServerName))

	// SSL 配置
	if server.SSLEnabled {
		builder.WriteString("\n")
		if server.SSLCert != "" {
			builder.WriteString(fmt.Sprintf("    ssl_certificate %s;\n", server.SSLCert))
		}
		if server.SSLKey != "" {
			builder.WriteString(fmt.Sprintf("    ssl_certificate_key %s;\n", server.SSLKey))
		}
		builder.WriteString("    ssl_protocols TLSv1.2 TLSv1.3;\n")
		builder.WriteString("    ssl_ciphers HIGH:!aNULL:!MD5;\n")
	}

	builder.WriteString("\n")

	// location 块
	for _, loc := range server.Locations {
		locContent, err := s.generateLocation(configType, &loc)
		if err != nil {
			return "", err
		}
		builder.WriteString(locContent)
	}

	builder.WriteString("}\n")
	return builder.String(), nil
}

// generateLocation 生成 location 块
func (s *NginxConfigGenerateService) generateLocation(configType dto.ConfigType, loc *dto.LocationConfig) (string, error) {
	if loc.Path == "" {
		return "", s.err.New("location path 不能为空", nil).ValidWithCtx()
	}

	var builder strings.Builder
	builder.WriteString(fmt.Sprintf("    location %s {\n", loc.Path))

	switch configType {
	case dto.ConfigTypeProxy:
		// 反向代理配置
		if loc.ProxyPass == "" {
			return "", s.err.New("反向代理模式下 proxy_pass 不能为空", nil).ValidWithCtx()
		}
		builder.WriteString(fmt.Sprintf("        proxy_pass %s;\n", loc.ProxyPass))
		builder.WriteString("        proxy_set_header Host $host;\n")
		builder.WriteString("        proxy_set_header X-Real-IP $remote_addr;\n")
		builder.WriteString("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n")
		builder.WriteString("        proxy_set_header X-Forwarded-Proto $scheme;\n")

		// WebSocket 支持
		if loc.EnableWebSocket {
			builder.WriteString("\n")
			builder.WriteString("        # WebSocket support\n")
			builder.WriteString("        proxy_http_version 1.1;\n")
			builder.WriteString("        proxy_set_header Upgrade $http_upgrade;\n")
			builder.WriteString("        proxy_set_header Connection \"upgrade\";\n")
		}

	case dto.ConfigTypeStatic:
		// 静态站点配置
		if loc.Root != "" {
			builder.WriteString(fmt.Sprintf("        root %s;\n", loc.Root))
		}
		if loc.Index != "" {
			builder.WriteString(fmt.Sprintf("        index %s;\n", loc.Index))
		}
		if loc.TryFiles != "" {
			builder.WriteString(fmt.Sprintf("        try_files %s;\n", loc.TryFiles))
		}
	}

	builder.WriteString("    }\n\n")
	return builder.String(), nil
}
